<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TaskDynamicsExample.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script src="MathJax/MathJax.js"></script>
<!-- To use the latest MathJax version instead, you can use: -->
<!--<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00332.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TaskDynamicsExample.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>How to create a new task dynamics.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>How to create a new task dynamics. </p>
<h1>Preliminaries </h1>
<p>Given a task \( f \circ rhs \) where \( f \) is a function, \( \circ \) is one of the following operators: \( \leq, = , \geq \) and \( rhs \) is vector, we define the task error function \( e = f - rhs \). <br />
 The goal of a task dynamics is to specify the desired value of one time derivative of \( e \), such that the value of \( f \) stays in a region that fulfills the task or converge to it.</p>
<p>In this example we will see how to implement the task dynamics</p>
<p>\( \dot{e}^* = -k_p(e) e \qquad (1) \)</p>
<p>that is a proportional-like dynamics with an adaptive gain, where</p>
<p>\( k_p(e) = a \exp(-b \left\|e\right\|) + c \qquad (2) \)</p>
<p>To keep it simple \( a \), \( b \), \( c \) and thus \( k_p \) will be scalars.</p>
<p>This task dynamics computes a desired first-order time derivative of the error function \( e \). We say its order is one.</p>
<h1>Implementation outline </h1>
<p>From the user point of view, a task dynamics can be just specified by its type and parameters (e.g. adaptive proportional with gain <code>a</code>, <code>b</code> and <code>c</code> in this example). This can be done independently of the task \( f \circ rhs \) with which it will be used. From the computational point of view, the task dynamics needs to be instantiated as a node of the computation graph taking the value and possibly the derivatives of \(f \) as an input. This step can only be done if the task is known.</p>
<p>At the code level, this duality of viewpoints translates into the implementation of two classes:</p><ol type="1">
<li>A user-dedicated class, deriving from <a class="el" href="a01624.html" title="This is a base class to describe how a task is to be regulated, i.e. ">tvm::task_dynamics::abstract::TaskDynamics</a> that acts as a lightweight description of the task and a factory for</li>
<li>A computation-related class, deriving from <a class="el" href="a01628.html" title="Base class for the implementation of a task dynamics. ">tvm::task_dynamics::abstract::TaskDynamicsImpl</a> that implements a node of the computation graph.</li>
</ol>
<p>We will call AdaptiveProportional the user-dedicated class. It simply needs to store <code>a</code>, <code>b</code> and <code>c</code>, and is required to override the two following methods </p><pre class="fragment">Order order_() const
std::unique_ptr&lt;TaskDynamicsImpl&gt; impl_(FunctionPtr f, constraint::Type t, const Eigen::VectorXd&amp; rhs) const
</pre><p>The first one has to return the task dynamics order (one, in our case), the second creates an instance of the computation-related class.</p>
<p>The second class could be implemented separately of the first but the convention taken in TVM is to make it a subclass of the first, with the name <code>Impl</code>. A few other classes rely on this convention such as <a class="el" href="a01632.html" title="Given a task dynamics value , compute the new value , , such that  where  and  are given bounds...">tvm::task_dynamics::Clamped</a>, that would not be compatible with our example if we didn't do so. This second class overrides the method </p><pre class="fragment">void updateValue()
</pre><p>which implements the computation of the desired error derivative, i.e. the formula (1) and (2) for our example. For that it will need to store store <code>a</code>, <code>b</code> and <code>c</code> as well.</p>
<h1>Implementation details </h1>
<p>As a direct transcription of the outline above, our <code>AdaptiveProportional</code> has the following declaration (assuming the proper namespaces): </p><pre><div class="fragment"><div class="line"><span class="keyword">class </span>AdaptiveProportional : <span class="keyword">public</span> abstract::TaskDynamics</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">class </span>Impl : <span class="keyword">public</span> task_dynamics::abstract::TaskDynamicsImpl { ... };</div><div class="line"></div><div class="line">    AdaptiveProportional(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c);</div><div class="line"></div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="a00354.html#a2104706f158c0b024e10716d3c176cad">task_dynamics::Order</a> order_() <span class="keyword">const override</span>;</div><div class="line">    std::unique_ptr&lt;task_dynamics::abstract::TaskDynamicsImpl&gt; impl_(<a class="code" href="a00347.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> f, <a class="code" href="a00348.html#ab6243a7da877a867f54ff7207959eb7c">constraint::Type</a> t, <span class="keyword">const</span> Eigen::VectorXd&amp; rhs) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">double</span> a_, b_, c_;</div><div class="line">};</div></div><!-- fragment --></pre><p> (The impl class is described below)</p>
<p>The implementation is straightforward:</p><ul>
<li>the contructor trivially assigns <code>a</code>, <code>b</code> and <code>c</code> to the relevant fields <pre><div class="fragment"><div class="line">AdaptiveProportional::AdaptiveProportional(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c)</div><div class="line"> : a_(a), b_(b), c_(c)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --></pre></li>
<li><code>order_()</code> simply returns <a class="el" href="a00354.html#a2104706f158c0b024e10716d3c176cada06c2cea18679d64399783748fa367bdd">tvm::task_dynamics::Order::One</a>.</li>
<li><code>impl_</code> is given the description of the task \( f \circ rhs \) through parameters <code>f</code>, <code>t</code> and <code>rhs</code>. From these and fields <code>a_</code>, <code>b_</code>, <code>c_</code>, it constructs a std::unique_ptr on <code>AdaptiveProportional::Impl:</code> <pre><div class="fragment"><div class="line">std::unique_ptr&lt;task_dynamics::abstract::TaskDynamicsImpl&gt; AdaptiveProportional::impl_(<a class="code" href="a00347.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> f, <a class="code" href="a00348.html#ab6243a7da877a867f54ff7207959eb7c">constraint::Type</a> t, <span class="keyword">const</span> Eigen::VectorXd&amp; rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> std::unique_ptr&lt;task_dynamics::abstract::TaskDynamicsImpl&gt;(<span class="keyword">new</span> Impl(f, t, rhs, a_, b_, c_));</div><div class="line">}</div></div><!-- fragment --></pre></li>
</ul>
<p>The <code>Impl</code> class is declared as </p><pre><div class="fragment"><div class="line"><span class="keyword">class </span>Impl : <span class="keyword">public</span> task_dynamics::abstract::TaskDynamicsImpl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Impl(<a class="code" href="a00347.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> f, <a class="code" href="a00348.html#ab6243a7da877a867f54ff7207959eb7c">constraint::Type</a> t, <span class="keyword">const</span> Eigen::VectorXd &amp; rhs, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c);</div><div class="line">  <span class="keywordtype">void</span> updateValue() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> a_, b_, c_;</div><div class="line">};</div></div><!-- fragment --></pre><p>Once again, the constructor is straightforward. The main attention point is that it needs to call the constructor of TaskDynamicsImpl to pass it not only the parameters <code>f</code>, <code>t</code> and <code>rhs</code>, but also the order of the task dynamics. </p><pre><div class="fragment"><div class="line">AdaptiveProportional::Impl::Impl(<a class="code" href="a00347.html#a42313833bbb66bf5318f67e0dca5936a">FunctionPtr</a> f, <a class="code" href="a00348.html#ab6243a7da877a867f54ff7207959eb7c">constraint::Type</a> t, <span class="keyword">const</span> Eigen::VectorXd&amp; rhs, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c)</div><div class="line">  : TaskDynamicsImpl(task_dynamics::<a class="code" href="a00354.html#a2104706f158c0b024e10716d3c176cad">Order</a>::<a class="code" href="a00354.html#a2104706f158c0b024e10716d3c176cada06c2cea18679d64399783748fa367bdd">One</a>, f,t,rhs), a_(a), b_(b), c_(c)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --></pre><p>The <code>updateValue()</code> method is the heart of the implementation. It will be called by the computation graph to update the value of the TaskDynamicsImpl instance (accessible through the <code>value()</code> method). Within methods of <code>Impl</code>, we have access to the task parameters through the <code>function()</code>, <code>type()</code> and <code>rhs()</code> methods. Furthermore, we have access to the <code>value_</code> member, which is where to put the output of our computations. <br />
 The implementation is as follows </p><pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> AdaptiveProportional::Impl::updateValue()</div><div class="line">{</div><div class="line">  value_ = <span class="keyword">function</span>().value() - rhs();</div><div class="line">  <span class="keywordtype">double</span> kp = a_ * exp(-b_ * value_.norm()) + c_;</div><div class="line">  value_ *= -kp;</div><div class="line">}</div></div><!-- fragment --></pre><p> The first line stores (temporarily) the value of the error function \( e \) in <code>value_</code>. The second line computes the adaptive gain according to (2). The last line computes the desired error velocity as in (1) and store it in <code>value_</code>, as required.</p>
<h1>To go further </h1>
<h2>On this example </h2>
<p>The above implementation is a minimal working example, and could be improved or extended in several ways:</p><ul>
<li>Checking the validity of the input parameters <code>a_</code>, <code>b_</code>, <code>c_</code> in the constructor of <code>Impl</code>. These parameters should be non-negative. It would be even be better to check the validity <em>also</em> in the constructor of <code>AdaptiveProportional</code>, to report errors as early as possible, and at a place that will be more user-friendly.</li>
<li>Adding getter and setters for the parameters (with the required checks).</li>
<li>Having <code>a</code> and <code>c</code> be possibly diagonal matrices (represented by a vector) or full matrices. This would require additionnal checks on the vector/matrix sizes with respect to the size of \( f \).</li>
</ul>
<h2>General notes </h2>
<p>Here are some points to keep in minds when implementing new task dynamics:</p><ul>
<li>If you want your task dynamics to be included in the TVM you'll need to add the macro <code>TVM_DLLAPI</code> in front of both classes. This requires to include <code><a class="el" href="a00029.html">tvm/defs.h</a></code> </li>
<li>By default the computation of the task dynamics value only relies on the value of \( f \) (and its velocity for second-order task dynamics). The constructor of <code>TaskDynamicsImpl</code> ensures that the computation graph is properly designed for this case. If your task dynamics depends on other computations, e.g. if your computation relies also on a function \( g \), you need to declare the computation dependencies in the constructor of <code>Impl</code>. The constructor of <a class="el" href="a01628.html" title="Base class for the implementation of a task dynamics. ">tvm::task_dynamics::abstract::TaskDynamicsImpl</a> offers a good example of how to do so.</li>
</ul>
<h2>Example file </h2>
<p>example/TaskDynamicsExample.cpp </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d28a4824dc47e487b107a5db32ef43c4.html">examples</a></li><li class="navelem"><a class="el" href="a00332.html">TaskDynamicsExample.h</a></li>
    <li class="footer">Generated on Fri Jun 5 2020 15:06:03 for TVM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
